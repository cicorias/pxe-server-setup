#!/bin/bash
# 09-uefi-pxe-setup.sh
# Add UEFI PXE boot support to existing PXE server

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source configuration if it exists
if [[ -f "$SCRIPT_DIR/config.sh" ]]; then
    source "$SCRIPT_DIR/config.sh"
else
    echo -e "${RED}Error: config.sh not found.${NC}"
    echo "Please ensure PXE server is configured first."
    exit 1
fi

echo "=== Adding UEFI PXE Boot Support ==="

# Function to check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}Error: This script must be run as root or with sudo${NC}"
        exit 1
    fi
}

# Function to setup UEFI boot files
setup_uefi_boot_files() {
    echo -e "${BLUE}Setting up UEFI boot files...${NC}"
    
    # Create EFI directory structure
    echo -n "Creating EFI directory structure... "
    mkdir -p "$TFTP_ROOT/efi64"
    mkdir -p "$TFTP_ROOT/grub"
    echo -e "${GREEN}OK${NC}"
    
    # Copy GRUB EFI network boot file
    echo -n "Copying GRUB EFI network boot file... "
    if [[ -f "/usr/lib/grub/x86_64-efi-signed/grubnetx64.efi.signed" ]]; then
        cp "/usr/lib/grub/x86_64-efi-signed/grubnetx64.efi.signed" "$TFTP_ROOT/bootx64.efi"
    elif [[ -f "/usr/lib/grub/x86_64-efi/monolithic/grubnetx64.efi" ]]; then
        cp "/usr/lib/grub/x86_64-efi/monolithic/grubnetx64.efi" "$TFTP_ROOT/bootx64.efi"
    else
        echo -e "${RED}Failed${NC}"
        echo "Error: GRUB EFI network boot file not found"
        return 1
    fi
    echo -e "${GREEN}OK${NC}"
    
    # Set proper ownership
    echo -n "Setting file ownership... "
    chown -R tftp:tftp "$TFTP_ROOT/efi64" "$TFTP_ROOT/grub" "$TFTP_ROOT/bootx64.efi"
    chmod 644 "$TFTP_ROOT/bootx64.efi"
    echo -e "${GREEN}OK${NC}"
}

# Function to create GRUB configuration using native GRUB tools
create_grub_config() {
    echo -e "${BLUE}Creating GRUB configuration using native GRUB tools...${NC}"
    
    # Use the new GRUB configuration generator
    local grub_generator="$SCRIPT_DIR/grub-pxe-config-generator.sh"
    
    if [[ -f "$grub_generator" ]]; then
        echo -n "Generating GRUB configuration with native CLI tools... "
        if "$grub_generator" install; then
            echo -e "${GREEN}OK${NC}"
            echo "GRUB configuration created using grub-mkconfig and native tools"
        else
            echo -e "${YELLOW}Failed, using fallback method${NC}"
            create_grub_config_fallback
        fi
    else
        echo -e "${YELLOW}GRUB generator not found, using fallback method${NC}"
        create_grub_config_fallback
    fi
    
    # Set up grubenv for persistent settings (PR #11 recommendation)
    setup_grubenv
}

# Fallback function for manual GRUB configuration creation
create_grub_config_fallback() {
    echo -n "Creating grub.cfg (fallback method)... "
    
    # Enhanced fallback configuration following PR #11 patterns
    cat > "$TFTP_ROOT/grub/grub.cfg" << EOF
# GRUB Configuration for UEFI PXE Boot
# Generated by PXE Server Setup Script (Enhanced Fallback Method)
# Follows grub-cli-recommendations.md best practices
# Server: $PXE_SERVER_IP

# Load grubenv for persistent settings
load_env

# Set defaults (overrideable by grubenv)
if [ -z "\$timeout" ]; then
    set timeout=30
fi
if [ -z "\$default" ]; then
    set default="\${saved_entry}"
fi

# Load essential modules for PXE boot
insmod part_gpt
insmod part_msdos
insmod fat
insmod ext2
insmod net
insmod efinet
insmod tftp
insmod http
insmod chain
insmod linux
insmod multiboot
insmod multiboot2
insmod configfile
insmod normal
insmod test
insmod search
insmod search_fs_file
insmod search_fs_uuid
insmod search_label

# Network initialization with auto-discovery
net_bootp

# Set PXE server (prefer discovered, fallback to configured)
if [ -n "\$net_default_gateway" ]; then
    set pxe_server=\$net_default_gateway
else
    set pxe_server=$PXE_SERVER_IP
fi

set root=(tftp,\$pxe_server)

# === Local Boot Options ===

menuentry 'Boot from local disk' --class os --id=local {
    # Use search command for device discovery (grub-cli-recommendations.md)
    search --no-floppy --set=root --label /
    if [ -z "\$root" ]; then
        search --no-floppy --fs-uuid --set=root \$(probe -u (hd0,gpt1)) 2>/dev/null
    fi
    
    if [ -n "\$root" ]; then
        if [ -f /EFI/BOOT/BOOTX64.EFI ]; then
            chainloader /EFI/BOOT/BOOTX64.EFI
        elif [ -f /EFI/Microsoft/Boot/bootmgfw.efi ]; then
            chainloader /EFI/Microsoft/Boot/bootmgfw.efi
        else
            set root=(hd0)
            chainloader +1
        fi
    else
        set root=(hd0)
        chainloader +1
    fi
    boot
}

menuentry 'Memory Test (EFI)' --class memtest --id=memtest {
    # Search for memory test tools
    search --no-floppy --set=root --file /tools/memtest86.efi
    if [ -n "\$root" ] && [ -f /tools/memtest86.efi ]; then
        chainloader /tools/memtest86.efi
        boot
    fi
    
    echo "Memory test not available"
    echo "Install memtest86+ or place memtest86.efi in /tools/"
    echo "Press any key to return to menu..."
    read
}

EOF
    
    # Add dynamic ISO entries
    add_fallback_iso_entries
    
    # Add footer
    cat >> "$TFTP_ROOT/grub/grub.cfg" << EOF

# === System Information & Control ===

menuentry 'Network Information' --class info --id=netinfo {
    echo "=== Network Configuration ==="
    echo "PXE Server: \$pxe_server"
    echo "Client MAC: \$net_default_mac"
    echo "Client IP: \$net_default_ip"
    echo ""
    echo "Press any key to return to menu..."
    read
}

menuentry 'BIOS PXE Menu (Legacy)' --class legacy --id=legacy {
    echo 'To access BIOS PXE menu:'
    echo '1. Restart your system'
    echo '2. Enable Legacy/BIOS boot mode'
    echo '3. Boot from network again'
    echo ""
    echo 'Press any key to continue...'
    read
}

menuentry 'Reboot' --class restart --id=reboot {
    reboot
}

menuentry 'Shutdown' --class shutdown --id=shutdown {
    halt
}

EOF
    
    chown tftp:tftp "$TFTP_ROOT/grub/grub.cfg"
    chmod 644 "$TFTP_ROOT/grub/grub.cfg"
    echo -e "${GREEN}OK${NC}"
}

# Function to add ISO entries in fallback mode
add_fallback_iso_entries() {
    local ISO_STORAGE_DIR="${ISO_STORAGE_DIR:-$SCRIPT_DIR/../artifacts/iso}"
    local iso_count=0
    
    cat >> "$TFTP_ROOT/grub/grub.cfg" << EOF

# === Available ISO Installations ===

EOF
    
    if [[ -d "$TFTP_ROOT/kernels" ]]; then
        for kernel_dir in "$TFTP_ROOT/kernels"/*; do
            [[ -d "$kernel_dir" ]] || continue
            
            local iso_name
            iso_name=$(basename "$kernel_dir")
            local iso_info_file="${ISO_STORAGE_DIR}/${iso_name}.info"
            
            if [[ -f "$iso_info_file" && -f "$kernel_dir/vmlinuz" ]]; then
                # Source the ISO info
                local DISTRO="" VERSION="" ARCH="" RELEASE_NAME="" KERNEL_PATH="" INITRD_PATH="" BOOT_PARAMS=""
                source "$iso_info_file"
                
                # Replace placeholders following working-configuration.md patterns
                local boot_params_updated="${BOOT_PARAMS//##ISO_NAME##/$iso_name}"
                boot_params_updated="${boot_params_updated//##PXE_SERVER_IP##/$PXE_SERVER_IP}"
                boot_params_updated="${boot_params_updated//##NFS_ROOT##/$NFS_ROOT}"
                
                cat >> "$TFTP_ROOT/grub/grub.cfg" << ISOEOF

menuentry '$RELEASE_NAME' --class linux --id=$iso_name {
    echo 'Loading $RELEASE_NAME...'
    linux /kernels/$iso_name/vmlinuz $boot_params_updated
    initrd /initrd/$iso_name/initrd
    boot
}
ISOEOF
                ((iso_count++))
            fi
        done
    fi
    
    if [[ $iso_count -eq 0 ]]; then
        cat >> "$TFTP_ROOT/grub/grub.cfg" << EOF
# No ISOs available yet
# Run: sudo ./scripts/08-iso-manager.sh add <iso-file>

EOF
    fi
    
    echo "  Added $iso_count ISO entries"
}

# Function to set up grubenv following PR #11 recommendations
setup_grubenv() {
    echo -n "Setting up GRUB environment (grubenv)... "
    
    local grubenv_file="$TFTP_ROOT/grub/grubenv"
    local grub_utilities="$SCRIPT_DIR/grub-utilities.sh"
    
    if [[ -f "$grub_utilities" ]]; then
        # Use grub-utilities to manage grubenv
        if "$grub_utilities" grubenv list "$grubenv_file" >/dev/null 2>&1; then
            # Set default to local boot for safety
            "$grub_utilities" grubenv set "$grubenv_file" saved_entry local >/dev/null 2>&1
            chown tftp:tftp "$grubenv_file"
            chmod 644 "$grubenv_file"
            echo -e "${GREEN}OK${NC}"
        else
            echo -e "${YELLOW}Skipped (grubenv tools not available)${NC}"
        fi
    else
        echo -e "${YELLOW}Skipped (grub-utilities not found)${NC}"
    fi
}

# Function to update DHCP configuration for UEFI support
update_dhcp_config() {
    echo -e "${BLUE}Updating DHCP configuration for UEFI support...${NC}"
    
    # Backup current DHCP config
    echo -n "Backing up DHCP configuration... "
    cp /etc/dhcp/dhcpd.conf "/etc/dhcp/dhcpd.conf.backup.$(date +%Y%m%d_%H%M%S)"
    echo -e "${GREEN}OK${NC}"
    
    # Update DHCP config to support both BIOS and UEFI
    echo -n "Adding UEFI PXE support to DHCP... "
    
    # Add UEFI detection and boot file selection to DHCP config
    cat >> /etc/dhcp/dhcpd.conf << 'EOF'

# UEFI PXE Boot Support
# Detect client architecture and provide appropriate boot file
option arch code 93 = unsigned integer 16;

class "pxeclients" {
  match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
  if option arch = 00:07 {
    # x86_64 UEFI
    filename "bootx64.efi";
  } else if option arch = 00:09 {
    # x86_64 UEFI alternative
    filename "bootx64.efi";
  } else if option arch = 00:0b {
    # aarch64 UEFI
    filename "bootaa64.efi";
  } else {
    # Legacy BIOS (default)
    filename "pxelinux.0";
  }
}
EOF
    
    echo -e "${GREEN}OK${NC}"
    
    # Test DHCP configuration
    echo -n "Testing DHCP configuration... "
    if dhcpd -t -cf /etc/dhcp/dhcpd.conf; then
        echo -e "${GREEN}Valid${NC}"
    else
        echo -e "${RED}Invalid${NC}"
        echo "Restoring backup..."
        cp "/etc/dhcp/dhcpd.conf.backup.$(date +%Y%m%d_%H%M%S)" /etc/dhcp/dhcpd.conf
        return 1
    fi
}

# Function to restart services
restart_services() {
    echo -e "${BLUE}Restarting services...${NC}"
    
    echo -n "Restarting TFTP service... "
    if systemctl restart tftpd-hpa; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${RED}Failed${NC}"
    fi
    
    echo -n "Restarting DHCP service... "
    if systemctl restart isc-dhcp-server; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${RED}Failed${NC}"
    fi
}

# Function to verify setup
verify_uefi_setup() {
    echo -e "${BLUE}Verifying UEFI PXE setup...${NC}"
    
    # Check UEFI boot file
    echo -n "Checking UEFI boot file... "
    if [[ -f "$TFTP_ROOT/bootx64.efi" ]]; then
        echo -e "${GREEN}Present${NC}"
    else
        echo -e "${RED}Missing${NC}"
        return 1
    fi
    
    # Check GRUB config
    echo -n "Checking GRUB configuration... "
    if [[ -f "$TFTP_ROOT/grub/grub.cfg" ]]; then
        echo -e "${GREEN}Present${NC}"
    else
        echo -e "${RED}Missing${NC}"
        return 1
    fi
    
    # Check service status
    echo -n "Checking TFTP service... "
    if systemctl is-active tftpd-hpa >/dev/null 2>&1; then
        echo -e "${GREEN}Running${NC}"
    else
        echo -e "${RED}Stopped${NC}"
    fi
    
    echo -n "Checking DHCP service... "
    if systemctl is-active isc-dhcp-server >/dev/null 2>&1; then
        echo -e "${GREEN}Running${NC}"
    else
        echo -e "${RED}Stopped${NC}"
    fi
}

# Function to show summary
show_summary() {
    echo
    echo -e "${GREEN}=== UEFI PXE Setup Complete ===${NC}"
    echo "Boot File Support:"
    echo "  • BIOS (Generation 1): pxelinux.0"
    echo "  • UEFI (Generation 2): bootx64.efi"
    echo
    echo "DHCP Configuration:"
    echo "  • Automatic client architecture detection"
    echo "  • Serves appropriate boot file based on client type"
    echo
    echo "GRUB Menu:"
    echo "  • $TFTP_ROOT/grub/grub.cfg"
    echo "  • Simplified UEFI menu with Ubuntu option"
    echo
    echo "Testing:"
    echo "  • Generation 1 VM: Will get BIOS PXE menu (pxelinux)"
    echo "  • Generation 2 VM: Will get UEFI GRUB menu"
    echo
    echo "Your Generation 2 VM should now boot successfully!"
}

# Main execution
main() {
    echo "Starting UEFI PXE boot configuration..."
    echo "Date: $(date)"
    echo "User: $(whoami)"
    echo "Host: $(hostname)"
    echo

    check_root
    setup_uefi_boot_files
    create_grub_config
    update_dhcp_config
    restart_services
    verify_uefi_setup
    show_summary
}

# Run main function
main "$@"
