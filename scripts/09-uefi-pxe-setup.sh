#!/bin/bash
# 09-uefi-pxe-setup.sh
# Add UEFI PXE boot support to existing PXE server

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source configuration if it exists
if [[ -f "$SCRIPT_DIR/config.sh" ]]; then
    source "$SCRIPT_DIR/config.sh"
else
    echo -e "${RED}Error: config.sh not found.${NC}"
    echo "Please ensure PXE server is configured first."
    exit 1
fi

echo "=== Adding UEFI PXE Boot Support ==="

# Function to check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}Error: This script must be run as root or with sudo${NC}"
        exit 1
    fi
}

# Function to setup UEFI boot files
setup_uefi_boot_files() {
    echo -e "${BLUE}Setting up UEFI boot files...${NC}"
    
    # Create EFI directory structure
    echo -n "Creating EFI directory structure... "
    mkdir -p "$TFTP_ROOT/efi64"
    mkdir -p "$TFTP_ROOT/grub"
    echo -e "${GREEN}OK${NC}"
    
    # Copy GRUB EFI network boot file
    echo -n "Copying GRUB EFI network boot file... "
    if [[ -f "/usr/lib/grub/x86_64-efi-signed/grubnetx64.efi.signed" ]]; then
        cp "/usr/lib/grub/x86_64-efi-signed/grubnetx64.efi.signed" "$TFTP_ROOT/bootx64.efi"
    elif [[ -f "/usr/lib/grub/x86_64-efi/monolithic/grubnetx64.efi" ]]; then
        cp "/usr/lib/grub/x86_64-efi/monolithic/grubnetx64.efi" "$TFTP_ROOT/bootx64.efi"
    else
        echo -e "${RED}Failed${NC}"
        echo "Error: GRUB EFI network boot file not found"
        return 1
    fi
    echo -e "${GREEN}OK${NC}"
    
    # Set proper ownership
    echo -n "Setting file ownership... "
    chown -R tftp:tftp "$TFTP_ROOT/efi64" "$TFTP_ROOT/grub" "$TFTP_ROOT/bootx64.efi"
    chmod 644 "$TFTP_ROOT/bootx64.efi"
    echo -e "${GREEN}OK${NC}"
}

# Function to create GRUB configuration
create_grub_config() {
    echo -e "${BLUE}Creating GRUB configuration...${NC}"
    
    # Set default ISO storage directory if not defined
    local ISO_STORAGE_DIR="${ISO_STORAGE_DIR:-$SCRIPT_DIR/../artifacts/iso}"
    
    echo -n "Creating grub.cfg... "
    cat > "$TFTP_ROOT/grub/grub.cfg" << EOF
# GRUB Configuration for UEFI PXE Boot
# Generated by PXE Server Setup Script
# Server: $PXE_SERVER_IP

set timeout=30
set default=0

# Load required modules
insmod net
insmod efinet
insmod tftp
insmod http

# Set network configuration
set net_default_server=$PXE_SERVER_IP

menuentry 'Boot from local disk' --id=local {
    # Try to boot from local disk
    set root=(hd0)
    chainloader /EFI/BOOT/BOOTX64.EFI
    boot
}

menuentry 'Memory Test (EFI)' --id=memtest {
    # Would need EFI memtest
    echo "EFI Memory test not available"
    echo "Press any key to return to menu..."
    read
}

# Ubuntu Server 24.04.1 (if available)
if [ -f /kernels/ubuntu-24.04.1-live-server-amd64/vmlinuz ]; then
menuentry 'Ubuntu Server 24.04.1' --id=ubuntu-24041 {
    echo 'Loading Ubuntu Server 24.04.1...'
    linux /kernels/ubuntu-24.04.1-live-server-amd64/vmlinuz boot=casper url=http://$PXE_SERVER_IP/iso/ubuntu-24.04.1-live-server-amd64/ ip=dhcp
    initrd /initrd/ubuntu-24.04.1-live-server-amd64/initrd
    boot
}
fi

EOF
    
    # Add dynamic ISO and IMG entries
    echo -n "Adding available ISO and IMG entries... "
    local iso_count=0
    local img_count=0
    
    if [[ -d "$TFTP_ROOT/kernels" ]]; then
        for kernel_dir in "$TFTP_ROOT/kernels"/*; do
            [[ -d "$kernel_dir" ]] || continue
            
            local image_name
            image_name=$(basename "$kernel_dir")
            local iso_info_file="${ISO_STORAGE_DIR}/${image_name}.info"
            local img_info_file="${IMG_STORAGE_DIR:-$SCRIPT_DIR/../artifacts/img}/${image_name}.info"
            
            # Check for ISO files first
            if [[ -f "$iso_info_file" && -f "$kernel_dir/vmlinuz" ]]; then
                # Source the ISO info
                source "$iso_info_file"
                local boot_params_updated="${BOOT_PARAMS//##ISO_NAME##/$image_name}"
                
                cat >> "$TFTP_ROOT/grub/grub.cfg" << ISOEOF

menuentry '$RELEASE_NAME' --id=$image_name {
    echo 'Loading $RELEASE_NAME...'
    linux /kernels/$image_name/vmlinuz $boot_params_updated
    initrd /initrd/$image_name/initrd
    boot
}
ISOEOF
                ((iso_count++))
                
            # Check for IMG files
            elif [[ -f "$img_info_file" ]]; then
                # Source the IMG info
                source "$img_info_file"
                local boot_params_updated="${BOOT_PARAMS//##IMG_NAME##/$image_name}"
                
                # For IMG files, we have two options:
                # 1. If kernel/initrd were extracted, use TFTP boot with HTTP root
                # 2. If no kernel/initrd, use pure HTTP boot (requires special handling)
                
                if [[ -f "$kernel_dir/vmlinuz" ]]; then
                    # Option 1: Extracted kernel/initrd with HTTP IMG
                    cat >> "$TFTP_ROOT/grub/grub.cfg" << IMGEOF

menuentry '$RELEASE_NAME (IMG)' --id=$image_name {
    echo 'Loading $RELEASE_NAME from IMG...'
    linux /kernels/$image_name/vmlinuz $boot_params_updated
    initrd /initrd/$image_name/initrd
    boot
}
IMGEOF
                else
                    # Option 2: Pure HTTP boot (experimental)
                    cat >> "$TFTP_ROOT/grub/grub.cfg" << HTTPEOF

menuentry '$RELEASE_NAME (HTTP IMG)' --id=$image_name {
    echo 'Loading $RELEASE_NAME via HTTP...'
    echo 'Downloading IMG file: $image_name.img'
    # Note: This requires the OS to support HTTP root parameter
    # Most distributions do not support this natively
    linux16 (http,$PXE_SERVER_IP)/images/$image_name.img
}
HTTPEOF
                fi
                ((img_count++))
            fi
        done
    fi
    
    # Also check for IMG files without extracted kernels (HTTP-only boot)
    local IMG_STORAGE_DIR="${IMG_STORAGE_DIR:-$SCRIPT_DIR/../artifacts/img}"
    if [[ -d "$IMG_STORAGE_DIR" ]]; then
        for img_file in "$IMG_STORAGE_DIR"/*.img; do
            [[ -f "$img_file" ]] || continue
            
            local img_filename
            img_filename=$(basename "$img_file")
            local img_name="${img_filename%.img}"
            local img_info_file="$IMG_STORAGE_DIR/${img_name}.info"
            
            # Skip if we already added this IMG via kernel directory
            if [[ -d "$TFTP_ROOT/kernels/$img_name" ]]; then
                continue
            fi
            
            if [[ -f "$img_info_file" ]]; then
                source "$img_info_file"
                
                cat >> "$TFTP_ROOT/grub/grub.cfg" << PUREIMGEOF

menuentry '$RELEASE_NAME (Pure IMG)' --id=$img_name {
    echo 'Loading $RELEASE_NAME via HTTP IMG...'
    echo 'IMG URL: http://$PXE_SERVER_IP/images/$img_name.img'
    echo 'This requires OS support for HTTP IMG loading'
    echo 'Press any key to continue...'
    read
    # Experimental: try to load IMG directly
    # This may not work with all distributions
    configfile (http,$PXE_SERVER_IP)/images/$img_name.img
}
PUREIMGEOF
                ((img_count++))
            fi
        done
    fi
    
    echo -e "${GREEN}$iso_count ISOs, $img_count IMGs added${NC}"
    
    # Add the remaining static entries
    cat >> "$TFTP_ROOT/grub/grub.cfg" << EOF

menuentry 'Reboot' --id=reboot {
    reboot
}

menuentry 'Shutdown' --id=shutdown {
    halt
}
EOF
    
    chown tftp:tftp "$TFTP_ROOT/grub/grub.cfg"
    chmod 644 "$TFTP_ROOT/grub/grub.cfg"
    echo -e "${GREEN}OK${NC}"
}

# Function to update DHCP configuration for UEFI support
update_dhcp_config() {
    echo -e "${BLUE}Updating DHCP configuration for UEFI support...${NC}"
    
    # Backup current DHCP config
    echo -n "Backing up DHCP configuration... "
    cp /etc/dhcp/dhcpd.conf "/etc/dhcp/dhcpd.conf.backup.$(date +%Y%m%d_%H%M%S)"
    echo -e "${GREEN}OK${NC}"
    
    # Update DHCP config to support both BIOS and UEFI
    echo -n "Adding UEFI PXE support to DHCP... "
    
    # Add UEFI detection and boot file selection to DHCP config (UEFI only)
    cat >> /etc/dhcp/dhcpd.conf << 'EOF'

# UEFI PXE Boot Support (UEFI-only)
# Detect client architecture and provide appropriate boot file
option arch code 93 = unsigned integer 16;

class "pxeclients" {
  match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
  if option arch = 00:07 {
    # x86_64 UEFI
    filename "bootx64.efi";
  } else if option arch = 00:09 {
    # x86_64 UEFI alternative
    filename "bootx64.efi";
  } else if option arch = 00:0b {
    # aarch64 UEFI
    filename "bootaa64.efi";
  }
  # Note: BIOS/Legacy boot removed - UEFI only
}
EOF
    
    echo -e "${GREEN}OK${NC}"
    
    # Test DHCP configuration
    echo -n "Testing DHCP configuration... "
    if dhcpd -t -cf /etc/dhcp/dhcpd.conf; then
        echo -e "${GREEN}Valid${NC}"
    else
        echo -e "${RED}Invalid${NC}"
        echo "Restoring backup..."
        cp "/etc/dhcp/dhcpd.conf.backup.$(date +%Y%m%d_%H%M%S)" /etc/dhcp/dhcpd.conf
        return 1
    fi
}

# Function to restart services
restart_services() {
    echo -e "${BLUE}Restarting services...${NC}"
    
    echo -n "Restarting TFTP service... "
    if systemctl restart tftpd-hpa; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${RED}Failed${NC}"
    fi
    
    echo -n "Restarting DHCP service... "
    if systemctl restart isc-dhcp-server; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${RED}Failed${NC}"
    fi
}

# Function to verify setup
verify_uefi_setup() {
    echo -e "${BLUE}Verifying UEFI PXE setup...${NC}"
    
    # Check UEFI boot file
    echo -n "Checking UEFI boot file... "
    if [[ -f "$TFTP_ROOT/bootx64.efi" ]]; then
        echo -e "${GREEN}Present${NC}"
    else
        echo -e "${RED}Missing${NC}"
        return 1
    fi
    
    # Check GRUB config
    echo -n "Checking GRUB configuration... "
    if [[ -f "$TFTP_ROOT/grub/grub.cfg" ]]; then
        echo -e "${GREEN}Present${NC}"
    else
        echo -e "${RED}Missing${NC}"
        return 1
    fi
    
    # Check service status
    echo -n "Checking TFTP service... "
    if systemctl is-active tftpd-hpa >/dev/null 2>&1; then
        echo -e "${GREEN}Running${NC}"
    else
        echo -e "${RED}Stopped${NC}"
    fi
    
    echo -n "Checking DHCP service... "
    if systemctl is-active isc-dhcp-server >/dev/null 2>&1; then
        echo -e "${GREEN}Running${NC}"
    else
        echo -e "${RED}Stopped${NC}"
    fi
}

# Function to show summary
show_summary() {
    echo
    echo -e "${GREEN}=== UEFI PXE Setup Complete ===${NC}"
    echo "Boot File Support:"
    echo "  • UEFI only: bootx64.efi, bootaa64.efi"
    echo
    echo "DHCP Configuration:"
    echo "  • Automatic client architecture detection"
    echo "  • Serves appropriate boot file based on client type"
    echo
    echo "GRUB Menu:"
    echo "  • $TFTP_ROOT/grub/grub.cfg"
    echo "  • UEFI-only menu with OS installation options"
    echo
    echo "Testing:"
    echo "  • UEFI VMs: Will get UEFI GRUB menu"
    echo "  • Physical UEFI systems: Will get UEFI GRUB menu"
    echo
    echo "Your UEFI systems should now boot successfully!"
}

# Main execution
main() {
    echo "Starting UEFI PXE boot configuration..."
    echo "Date: $(date)"
    echo "User: $(whoami)"
    echo "Host: $(hostname)"
    echo

    check_root
    setup_uefi_boot_files
    create_grub_config
    update_dhcp_config
    restart_services
    verify_uefi_setup
    show_summary
}

# Run main function
main "$@"
