#!/bin/bash
# grub-pxe-config-generator.sh
# GRUB configuration generator for PXE boot entries
# This script creates a GRUB configuration fragment for PXE boot

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source configuration if it exists
if [[ -f "$SCRIPT_DIR/config.sh" ]]; then
    source "$SCRIPT_DIR/config.sh"
else
    echo -e "${RED}Error: config.sh not found.${NC}" >&2
    exit 1
fi

# Function to generate GRUB configuration using templates
generate_grub_config() {
    local output_file="${1:-}"
    local config_type="${2:-pxe}"  # pxe or standard
    
    if [[ -z "$output_file" ]]; then
        echo -e "${RED}Error: Output file required${NC}" >&2
        return 1
    fi
    
    echo -e "${BLUE}Generating GRUB configuration for PXE boot...${NC}"
    
    # Create temporary GRUB environment for PXE
    local temp_grub_dir="/tmp/grub-pxe-$$"
    local temp_default="/tmp/grub-default-$$"
    
    # Cleanup function
    cleanup() {
        [[ -n "${temp_grub_dir:-}" ]] && rm -rf "$temp_grub_dir" 2>/dev/null || true
        [[ -n "${temp_default:-}" ]] && rm -f "$temp_default" 2>/dev/null || true
    }
    trap cleanup EXIT
    
    # Create temporary GRUB environment
    mkdir -p "$temp_grub_dir"
    
    # Create temporary grub default configuration for PXE
    cat > "$temp_default" << EOF
# GRUB defaults for PXE boot generation
GRUB_TIMEOUT=30
GRUB_DEFAULT=0
GRUB_TIMEOUT_STYLE=menu
GRUB_TERMINAL_INPUT=console
GRUB_TERMINAL_OUTPUT=console
GRUB_CMDLINE_LINUX_DEFAULT=""
GRUB_CMDLINE_LINUX=""
GRUB_DISABLE_RECOVERY=true
GRUB_DISABLE_OS_PROBER=true

# PXE-specific settings
GRUB_PXE_SERVER_IP="$PXE_SERVER_IP"
GRUB_TFTP_ROOT="$TFTP_ROOT"
EOF
    
    # Generate base configuration using grub-mkconfig
    echo -n "Running grub-mkconfig... "
    if GRUB_CONFIG_FILE="$temp_default" grub-mkconfig > "$output_file" 2>/dev/null; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${YELLOW}Failed, using fallback method${NC}"
        generate_fallback_config "$output_file"
    fi
    
    # Add PXE-specific configuration
    add_pxe_entries "$output_file"
    
    return 0
}

# Function to generate fallback configuration when grub-mkconfig fails
generate_fallback_config() {
    local output_file="$1"
    
    cat > "$output_file" << EOF
# GRUB Configuration for UEFI PXE Boot
# Generated by PXE Server Setup Script using GRUB tools
# Server: $PXE_SERVER_IP

set timeout=30
set default=0

# Load required modules for network PXE boot
insmod part_gpt
insmod part_msdos
insmod fat
insmod ext2
insmod net
insmod efinet
insmod tftp
insmod http
insmod chain
insmod linux
insmod multiboot
insmod multiboot2

# Set network configuration
set net_default_server=$PXE_SERVER_IP
set root=(tftp,$PXE_SERVER_IP)

# Network initialization
net_add_addr \$net_default_mac ipv4 dhcp

EOF
}

# Function to add PXE-specific menu entries
add_pxe_entries() {
    local config_file="$1"
    
    echo -n "Adding PXE boot entries... "
    
    # Add standard PXE entries
    cat >> "$config_file" << EOF

# === PXE Boot Menu Entries ===

menuentry 'Boot from local disk' --id=local {
    # Try to boot from local disk
    search --no-floppy --set=root --label /
    if [ -f /EFI/BOOT/BOOTX64.EFI ]; then
        chainloader /EFI/BOOT/BOOTX64.EFI
    elif [ -f /EFI/Microsoft/Boot/bootmgfw.efi ]; then
        chainloader /EFI/Microsoft/Boot/bootmgfw.efi
    else
        # Fallback to first hard drive
        set root=(hd0)
        chainloader +1
    fi
    boot
}

menuentry 'Memory Test (EFI)' --id=memtest {
    if [ -f /tools/memtest86.efi ]; then
        chainloader /tools/memtest86.efi
    else
        echo "EFI Memory test not available"
        echo "Press any key to return to menu..."
        read
    fi
}

EOF

    # Add entries for available ISOs
    add_iso_entries "$config_file"
    
    # Add utility entries
    cat >> "$config_file" << EOF

menuentry 'BIOS PXE Menu (Legacy)' --id=legacy {
    echo 'Switching to legacy BIOS PXE menu...'
    echo 'Restart with Legacy/BIOS mode for full menu'
    echo 'Press any key to continue...'
    read
}

menuentry 'Network Information' --id=netinfo {
    echo "Network Configuration:"
    echo "PXE Server: $PXE_SERVER_IP"
    echo "Interface: \$net_default_mac"
    echo ""
    echo "Available boot options will be shown in main menu"
    echo "Press any key to return to menu..."
    read
}

menuentry 'Reboot' --id=reboot {
    reboot
}

menuentry 'Shutdown' --id=shutdown {
    halt
}

EOF
    
    echo -e "${GREEN}OK${NC}"
}

# Function to add ISO entries to GRUB configuration
add_iso_entries() {
    local config_file="$1"
    local iso_storage_dir="$(dirname "$SCRIPT_DIR")/artifacts/iso"
    
    if [[ ! -d "$iso_storage_dir" ]]; then
        return 0
    fi
    
    echo -n "Scanning for ISO entries... "
    local iso_count=0
    
    # Add comment section for ISO entries
    cat >> "$config_file" << EOF

# === Available ISO Installations ===

EOF
    
    # Process each ISO file
    for iso_info in "$iso_storage_dir"/*.info; do
        if [[ -f "$iso_info" ]]; then
            local iso_name
            iso_name=$(basename "$iso_info" .info)
            
            # Source ISO information
            local DISTRO="" VERSION="" ARCH="" RELEASE_NAME="" KERNEL_PATH="" INITRD_PATH="" BOOT_PARAMS=""
            source "$iso_info" 2>/dev/null || continue
            
            if [[ -n "$RELEASE_NAME" && -f "$TFTP_ROOT/kernels/$iso_name/vmlinuz" ]]; then
                add_single_iso_entry "$config_file" "$iso_name" "$RELEASE_NAME" "$BOOT_PARAMS"
                ((iso_count++))
            fi
        fi
    done
    
    if [[ $iso_count -eq 0 ]]; then
        cat >> "$config_file" << EOF
# No ISOs available yet
# Run: sudo ./scripts/08-iso-manager.sh add <iso-file>

EOF
    fi
    
    echo -e "${GREEN}$iso_count ISOs${NC}"
}

# Function to add a single ISO entry
add_single_iso_entry() {
    local config_file="$1"
    local iso_name="$2"
    local release_name="$3"
    local boot_params="$4"
    
    # Replace placeholders in boot parameters
    local boot_params_updated="${boot_params//##ISO_NAME##/$iso_name}"
    
    cat >> "$config_file" << EOF
menuentry '$release_name' --id=$iso_name {
    echo 'Loading $release_name...'
    linux /kernels/$iso_name/vmlinuz $boot_params_updated
    initrd /initrd/$iso_name/initrd
    boot
}

EOF
}

# Function to install GRUB configuration
install_grub_config() {
    local source_config="$1"
    local target_config="${2:-$TFTP_ROOT/grub/grub.cfg}"
    
    echo -e "${BLUE}Installing GRUB configuration...${NC}"
    
    # Ensure target directory exists
    mkdir -p "$(dirname "$target_config")"
    
    # Copy configuration
    echo -n "Installing configuration to $target_config... "
    cp "$source_config" "$target_config"
    
    # Set proper ownership and permissions
    chown tftp:tftp "$target_config"
    chmod 644 "$target_config"
    
    echo -e "${GREEN}OK${NC}"
    
    # Validate configuration
    echo -n "Validating GRUB syntax... "
    if grub-script-check "$target_config" 2>/dev/null; then
        echo -e "${GREEN}Valid${NC}"
    else
        echo -e "${YELLOW}Warning: Syntax validation failed${NC}"
    fi
}

# Function to create custom GRUB.d script for PXE
create_grub_d_script() {
    local grub_d_script="/etc/grub.d/42_pxe_entries"
    
    echo -e "${BLUE}Creating custom GRUB.d script...${NC}"
    
    cat > "$grub_d_script" << 'EOF'
#!/bin/bash
# 42_pxe_entries
# Custom GRUB script for PXE boot entries
# This script is called by grub-mkconfig to generate PXE-specific entries

set -e

# Only generate entries if this is a PXE configuration
if [ -n "$GRUB_PXE_SERVER_IP" ] && [ -n "$GRUB_TFTP_ROOT" ]; then
    
    cat << EOM
# === PXE Boot Entries ===
# Generated by 42_pxe_entries

menuentry 'Boot from local disk' --id=local {
    search --no-floppy --set=root --label /
    if [ -f /EFI/BOOT/BOOTX64.EFI ]; then
        chainloader /EFI/BOOT/BOOTX64.EFI
    else
        set root=(hd0)
        chainloader +1
    fi
    boot
}

EOM

    # Add ISO entries if available
    if [ -d "$GRUB_TFTP_ROOT/kernels" ]; then
        for iso_dir in "$GRUB_TFTP_ROOT/kernels"/*; do
            if [ -d "$iso_dir" ] && [ -f "$iso_dir/vmlinuz" ]; then
                iso_name=$(basename "$iso_dir")
                echo "menuentry 'Install $iso_name' --id=$iso_name {"
                echo "    linux /kernels/$iso_name/vmlinuz"
                echo "    initrd /initrd/$iso_name/initrd"
                echo "    boot"
                echo "}"
                echo ""
            fi
        done
    fi
    
    cat << EOM

menuentry 'Reboot' --id=reboot {
    reboot
}

menuentry 'Shutdown' --id=shutdown {
    halt
}

EOM

fi
EOF
    
    # Make executable
    chmod +x "$grub_d_script"
    echo -e "${GREEN}Created $grub_d_script${NC}"
}

# Main function
main() {
    local action="${1:-generate}"
    local output_file="${2:-/tmp/grub-pxe.cfg}"
    
    case "$action" in
        "generate")
            generate_grub_config "$output_file"
            echo "GRUB configuration generated: $output_file"
            ;;
        "install")
            local temp_config="/tmp/grub-pxe-generated.cfg"
            generate_grub_config "$temp_config"
            install_grub_config "$temp_config"
            rm -f "$temp_config"
            ;;
        "grub.d")
            create_grub_d_script
            ;;
        *)
            echo "Usage: $0 {generate|install|grub.d} [output_file]"
            echo "  generate [file] - Generate GRUB config to file (default: /tmp/grub-pxe.cfg)"
            echo "  install [file]  - Generate and install to TFTP root"
            echo "  grub.d          - Create custom GRUB.d script for system integration"
            exit 1
            ;;
    esac
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi